package test.jdbc;

import com.zaxxer.hikari.HikariDataSource;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.postgresql.util.PSQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import test.container.SwiftJdbcExtension;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(SwiftJdbcExtension.class)
public class StatementTest {

  private final static Logger log = LoggerFactory.getLogger(StatementTest.class);

  @TestTemplate
  void execute(DataSource dataSource) throws SQLException {
    String driverClassName = dataSource.unwrap(HikariDataSource.class).getDriverClassName();

    // 不指定autoGeneratedKeys, 无法获得生成的key(mysql的实现会抛出异常, 所以统一成必须指定)
    try (Connection connection = dataSource.getConnection()) {
      String sql = "insert into swift_user(name, status) values(?, ?)";
      try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
        ps.setQueryTimeout(1);
        ps.setString(1, "fantasy");
        ps.setInt(2, 1);
        // 没有返回内容(不包括生成的主键), 所以是false
        assertFalse(ps.execute());
        try (ResultSet resultSet = ps.getGeneratedKeys()) {
          assertTrue(resultSet.next());
          log.debug("key: {}", resultSet.getLong(1));
        }
      }
    }

    // pg专场
    if (driverClassName.contains("postgresql")) {
      // 不设置Statement.RETURN_GENERATED_KEYS, execute可以获取returning的内容
      try (Connection connection = dataSource.getConnection()) {
        String sql = "insert into swift_user(name, status) values(?, ?) returning id, name";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
          ps.setQueryTimeout(1);
          ps.setString(1, "fantasy");
          ps.setInt(2, 1);
          assertTrue(ps.execute());
          try (ResultSet resultSet = ps.getGeneratedKeys()) {
            assertFalse(resultSet.next());
          }
          try (ResultSet resultSet = ps.getResultSet()) {
            assertTrue(resultSet.next());
            long id = resultSet.getLong(1);
            String name = resultSet.getString(2);
            log.debug("id: {}, name: {}", id, name);
            assertTrue(id > 0);
            assertEquals("fantasy", name);
          }
        }
      }
      // 设置Statement.RETURN_GENERATED_KEYS, returning的内容将被忽略
      try (Connection connection = dataSource.getConnection()) {
        String sql = "insert into swift_user(name, status) values(?, ?) returning id";
        try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
          ps.setQueryTimeout(1);
          ps.setString(1, "fantasy");
          ps.setInt(2, 1);
          // 在指定autoGeneratedKeys的情况下, 就算有returning, 也会返回false
          assertFalse(ps.execute());
          try (ResultSet resultSet = ps.getGeneratedKeys()) {
            assertTrue(resultSet.next());
            log.debug("key: {}", resultSet.getLong(1));
          }
          assertNull(ps.getResultSet());
        }
      }

      // 尝试用execute取出返回的id
      try (Connection connection = dataSource.getConnection()) {
        String sql = "update swift_user set status = 1 returning id";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
          assertTrue(ps.execute());
          assertNotNull(ps.getResultSet());
          try (ResultSet resultSet = ps.getResultSet()) {
            while (resultSet.next()) {
              long id = resultSet.getLong(1);
              log.debug("key: {}", id);
              assertTrue(id > 0);
            }
          }
        }
      }
    }
  }

  @TestTemplate
  void executeUpdate(DataSource dataSource) throws SQLException {
    String driverClassName = dataSource.unwrap(HikariDataSource.class).getDriverClassName();
    // 取出生成的key
    try (Connection connection = dataSource.getConnection()) {
      String sql = "insert into swift_user(name, status) values(?, ?)";
      try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
        ps.setQueryTimeout(1);
        ps.setString(1, "fantasy");
        ps.setInt(2, 1);
        assertEquals(1, ps.executeUpdate());
        assertNull(ps.getResultSet());
        try (ResultSet resultSet = ps.getGeneratedKeys()) {
          assertTrue(resultSet.next());
          long id = resultSet.getLong(1);
          log.debug("key: {}", id);
          assertTrue(id > 0);
        }
      }
      // 尝试用executeUpdate取出returning返回的内容
      if (driverClassName.contains("postgresql")) {
        assertThrows(PSQLException.class, () -> {
          String sql2 = "insert into swift_user(name, status) values(?, ?) returning id";
          try (PreparedStatement ps = connection.prepareStatement(sql2)) {
            ps.setString(1, "fantasy2");
            ps.setInt(2, 2);
            ps.executeUpdate();
            // assertEquals(1, ps.executeUpdate());
            assertNotNull(ps.getResultSet());
            try (ResultSet resultSet = ps.getResultSet()) {
              assertTrue(resultSet.next());
              long id = resultSet.getLong(1);
              log.debug("key: {}", id);
              assertTrue(id > 0);
            }
          }
        });
      }
    }
  }

  @TestTemplate
  void executeBatch(DataSource dataSource) throws SQLException {
    String driverClassName = dataSource.unwrap(HikariDataSource.class).getDriverClassName();
    List<Object[]> params = List.of(
      new Object[]{"fantasy1", 1},
      new Object[]{"fantasy2", 2}
    );
    // 使用executeBatch, 并取出生成的主键
    try (Connection connection = dataSource.getConnection()) {
      String sql = "insert into swift_user(name, status) values(?, ?)";
      try (PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
        for (Object[] param : params) {
          ps.setString(1, param[0].toString());
          ps.setInt(2, (int)param[1]);
          ps.addBatch();
        }
        int[] batchResult = ps.executeBatch();
        assertTrue(Arrays.stream(batchResult).allMatch(i -> i == 1));
        assertEquals(params.size(), batchResult.length);

        List<Long> keyResult = new ArrayList<>(batchResult.length);
        try (ResultSet resultSet = ps.getGeneratedKeys()) {
          while (resultSet.next()) {
            long id = resultSet.getLong(1);
            log.debug("key: {}", id);
            assertTrue(id > 0);
            keyResult.add(id);
          }
        }
        assertEquals(params.size(), keyResult.size());
      }
    }
    if (driverClassName.contains("postgresql")) {
      try (Connection connection = dataSource.getConnection()) {
        String sql = "insert into swift_user(name, status) values(?, ?) returning id";
        try (PreparedStatement ps = connection.prepareStatement(sql)) {
          for (Object[] param : params) {
            ps.setString(1, param[0].toString());
            ps.setInt(2, (int)param[1]);
            ps.addBatch();
          }
          int[] batchResult = ps.executeBatch();
          assertEquals(params.size(), batchResult.length);
          assertNull(ps.getResultSet());
          try (ResultSet resultSet = ps.getGeneratedKeys()) {
            assertFalse(resultSet.next());
          }
        }
      }
    }
  }

  /**
   * 确保isLast不会抛出异常
   *
   * @param dataSource dataSource
   * @throws SQLException SQLException
   */
  @TestTemplate
  void isLast(DataSource dataSource) throws SQLException {
    try (Connection connection = dataSource.getConnection()) {
      PreparedStatement stmt = connection.prepareStatement("SELECT * FROM student");
      ResultSet rs = stmt.executeQuery();
      while (rs.next()) {
        boolean last = rs.isLast();
        log.debug("isLast: {}", last);
      }
    }
  }
}
